import itertools
from collections import Counter
from random import shuffle


def get_pyramidal_cycles(number_of_vertices, number) -> list:
    """Generates list of pyramidal cycles

    Args:
        number_of_vertices: how many vertices in cycle
        number: count of cycles

    Returns:
        list: cycles
    """

    cycles = []

    for _ in range(number):
        cycle_1 = list(range(1, number_of_vertices + 1))
        shuffle(cycle_1)
        cycles.append(
            sorted(itertools.takewhile(lambda x: x < number_of_vertices, cycle_1))
            + sorted(itertools.dropwhile(lambda x: x < number_of_vertices, cycle_1), reverse=True)
        )

    return cycles


def import_from_file(path: str) -> list:
    """Gets data from the file

    Args:
        path: path to the imported file

    Returns:
        list: list of 2-tuple x, y graphs
    """

    data_set = []

    for pair in open(path).read().split('\n\n'):
        if pair:
            x, y = pair.split('\n')
            data_set.append((
                tuple(map(int, x.strip().split())),
                tuple(map(int, y.strip().split()))
            ))

    return data_set


def import_from_vns_file(path: str) -> list:
    """Gets data from the file generated by VNS

    Args:
        path: path to the imported file

    Returns:
        list: list of 2-tuple x, y graphs
    """

    data_set = []

    data = open(path, 'r').readlines()
    while True:
        try:
            data.pop(0)
            x = data.pop(0).replace('	Initial Cycle 1: ', '').replace(',', ' ').strip().split()
            y = data.pop(0).replace('	Initial Cycle 2: ', '').replace(',', ' ').strip().split()
            data_set.append([tuple(map(int, x)), tuple(map(int, tuple(y)))])
            for _ in range(8):
                data.pop(0)
        except IndexError:
            break

    return data_set


def chunk(it, n):
    """Returns chunks of n elements each

    >>> list(chunk(range(10), 3))
    [
        [0, 1, 2, ],
        [3, 4, 5, ],
        [6, 7, 8, ],
        [9, ]
    ]

    >>> list(chunk(list(range(10)), 3))
    [
        [0, 1, 2, ],
        [3, 4, 5, ],
        [6, 7, 8, ],
        [9, ]
    ]
    """

    def _w(g):
        return lambda: tuple(itertools.islice(g, n))

    return iter(_w(iter(it)), ())


def find_vertices_with_multiedges(graph: dict, graph_type: bool) -> list:
    """Returns all vertices with multiedges

    Args:
        graph: dict of all vertices
        graph_type: True - directed, False - undirected

    Returns:
        list: vertices with multiedges
    """

    result = []
    passed_edges = []

    for vertex in graph.values():
        if graph_type:
            if vertex.outgoing_1 and vertex.outgoing_1 == vertex.outgoing_2:
                result.append(vertex)
        else:
            edges_counter = Counter(vertex.edges)
            for edge in filter(lambda x: edges_counter[x] == 2, edges_counter):
                if edge not in passed_edges:
                    passed_edges.append(edge)
                    result.append((vertex, edge))

    return result


def get_different_edge(edges: set, excluded_edge):
    """Gets edge

    Args:
        edges: set of edges
        excluded_edge: edge excluded from that set of edges

    Returns:
        Edge:
    """

    return ((edges - {excluded_edge}) if len(edges) > 1 else edges).pop()
